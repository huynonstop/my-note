

[Serve Static Nest recipes](https://docs.nestjs.com/recipes/serve-static)

[CRUD (resource) generators Nest recipes](https://docs.nestjs.com/recipes/crud-generator)

[CQRS Nest recipes](https://docs.nestjs.com/recipes/cqrs)

[Logger | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/logger)

[Compression | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/compression)

[HTTP module | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/http-module)

# SQL 

[SQL (TypeORM) Nest recipes](https://docs.nestjs.com/recipes/sql-typeorm)

[Prisma Nest recipes](https://docs.nestjs.com/recipes/prisma)

## Sequelize

[Sequelize | Sequelize ORM](https://sequelize.org/)

[RobinBuschmann/sequelize-typescript: Decorators and some other features for sequelize (github.com)](https://github.com/RobinBuschmann/sequelize-typescript)

[SQL (Sequelize) Nest recipes](https://docs.nestjs.com/recipes/sql-sequelize)

```bash
$ npm install --save @nestjs/sequelize sequelize sequelize-typescript {your-database}
$ npm install --save-dev @types/sequelize
```

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [
    SequelizeModule.forRoot({
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      models: [],
    }),
  ],
})
export class AppModule {}

// app.service.tsJS

import { Injectable } from '@nestjs/common';
import { Sequelize } from 'sequelize-typescript';

@Injectable()
export class AppService {
  constructor(private sequelize: Sequelize) {}
}
```

### Models

[RobinBuschmann/sequelize-typescript: Decorators and some other features for sequelize (github.com)](https://github.com/RobinBuschmann/sequelize-typescript#column)

Sequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database.

```typescript
// user.model.ts
import { Column, Model, Table } from 'sequelize-typescript';

@Table
export class User extends Model<User> {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;
}

// app.module.ts

import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './users/user.model';

@Module({
  imports: [
    SequelizeModule.forRoot({
      dialect: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      models: [User],
    }),
  ],
})
export class AppModule {}

// users.module.ts
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.model';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {} // Don't forget to import the UsersModule into the root AppModule

// This module uses the forFeature() method to define which models are registered in the current scope. With that in place, we can inject the UserModel into the UsersService using the @InjectModel() decorator

// users.service.ts
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { User } from './user.model';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User)
    private userModel: typeof User,
  ) {}

  async findAll(): Promise<User[]> {
    return this.userModel.findAll();
  }

  findOne(id: string): Promise<User> {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await user.destroy();
  }
}
```

If you want to use the repository outside of the module which imports `SequelizeModule.forFeature`, you'll need to re-export the providers generated by it. You can do this by exporting the whole module, like this:

```typescript
// users.module.ts
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './user.entity';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  exports: [SequelizeModule]
})
export class UsersModule {}

// Now if we import UsersModule in UserHttpModule, we can use @InjectModel(User) in the providers of the latter module.

// users-http.module.ts
import { Module } from '@nestjs/common';
import { UsersModule } from './users.module';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserHttpModule {}
```

### Relations

[RobinBuschmann/sequelize-typescript: Decorators and some other features for sequelize (github.com)](https://github.com/RobinBuschmann/sequelize-typescript#model-association)

|                             |                                                              |
| --------------------------- | ------------------------------------------------------------ |
| `One-to-one`                | Every row in the primary table has one and only one associated row in the foreign table |
| `One-to-many / Many-to-one` | Every row in the primary table has one or more related rows in the foreign table |
| `Many-to-many`              | Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table |

```typescript
// user.entity.ts
import { Column, Model, Table, HasMany } from 'sequelize-typescript';
import { Photo } from '../photos/photo.model';

@Table
export class User extends Model<User> {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;

  @HasMany(() => Photo)
  photos: Photo[];
}
```

### Auto-load models

> Manually adding models to the `models` array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both `autoLoadModels` and `synchronize` properties of the configuration object (passed into the `forRoot()` method) to `true`

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';

@Module({
  imports: [
    SequelizeModule.forRoot({
      ...
      autoLoadModels: true,
      synchronize: true,
    }), // With that option specified, every model registered through the forFeature() method will be automatically added to the models array of the configuration object.
  ],
})
export class AppModule {}
```

Note that models that aren't registered through the `forFeature()` method, but are only referenced from the model (via an association), won't be included.

### Transactions

https://en.wikipedia.org/wiki/Database_transaction

https://sequelize.org/v5/manual/transactions.html

Below is a sample implementation of a managed transaction (auto-callback).

First, we need to inject the `Sequelize` object into a class in the normal way:

```typescript
@Injectable()
export class UsersService {
  constructor(private sequelize: Sequelize) {} // sequelize-typescript
}
```

Now, we can use this object to create a transaction.

```typescript
async createMany() {
  try {
    await this.sequelize.transaction(async t => {
      const transactionHost = { transaction: t };

      await this.userModel.create(
          { firstName: 'Abraham', lastName: 'Lincoln' },
          transactionHost,
      );
      await this.userModel.create(
          { firstName: 'John', lastName: 'Boothe' },
          transactionHost,
      );
    });
  } catch (err) {
    // Transaction has been rolled back
    // err is whatever rejected the promise chain returned to the transaction callback
  }
}
```

Note that the `Sequelize` instance is used only to start the transaction. However, to test this class would require mocking the entire `Sequelize` object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., `TransactionRunner`) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.

### Migrations

[Manual | Sequelize](https://sequelize.org/v5/manual/migrations.html)

Migrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database.

Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. 

### Multiple databases

Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes **mandatory**.

```typescript
const defaultOptions = {
  dialect: 'postgres',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'db',
  synchronize: true,
};
// If you don't set the name for a connection, its name is set to default. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden.
@Module({
  imports: [
    SequelizeModule.forRoot({
      ...defaultOptions,
      host: 'user_db_host',
      models: [User],
    }),
    SequelizeModule.forRoot({
      ...defaultOptions,
      name: 'albumsConnection',
      host: 'album_db_host',
      models: [Album],
    }),
  ],
})
export class AppModule {}
// At this point, you have User and Album models registered with their own connection. With this setup, you have to tell the SequelizeModule.forFeature() method and the @InjectModel() decorator which connection should be used. If you do not pass any connection name, the default connection is used.
@Module({
  imports: [
    SequelizeModule.forFeature([User]),
    SequelizeModule.forFeature([Album], 'albumsConnection'),
  ],
})
export class AppModule {}
```

You can also inject the `Sequelize` instance for a given connection:

```typescript
@Injectable()
export class AlbumsService {
  constructor(
    @InjectConnection('albumsConnection')
    private sequelize: Sequelize,
  ) {}
}
```

It's also possible to inject any `Sequelize` instance to the providers:

```typescript
@Module({
  providers: [
    {
      provide: AlbumsService,
      useFactory: (albumsSequelize: Sequelize) => {
        return new AlbumsService(albumsSequelize);
      },
      inject: [getConnectionToken('albumsConnection')],
    },
  ],
})
export class AlbumsModule {}
```

### Testing

> When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up **custom providers**. Each registered model is automatically represented by a `<ModelName>Model` token, where `ModelName` is the name of your model class.

```typescript
// The @nestjs/sequelize package exposes the getModelToken() function which returns a prepared token based on a given model.
@Module({
  providers: [
    UsersService,
    {
      provide: getModelToken(User),
      useValue: mockModel,
    },
  ],
})
export class UsersModule {}
// Now a substitute mockModel will be used as the UserModel. Whenever any class asks for UserModel using an @InjectModel() decorator, Nest will use the registered mockModel object.
```

### Async configuration[#](https://docs.nestjs.com/techniques/database#async-configuration-1)

# NoSQL (Mongo)

[MongoDB (Mongoose) Nest recipes](https://docs.nestjs.com/recipes/mongodb)

https://mongoosejs.com/docs/connections.html

```bash
$ npm install --save @nestjs/mongoose mongoose
```

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [MongooseModule.forRoot('mongodb://localhost/nest')],
})
export class AppModule {}
```

The `forRoot()` method accepts the same configuration object as `mongoose.connect()` from the Mongoose package

### Model injection

[Mongoose v5.11.8: Schemas ](https://mongoosejs.com/docs/guide.html)

[Mongoose v5.11.8: Models ](https://mongoosejs.com/docs/models.html)

Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. Schemas are used to define Models. Models are responsible for creating and reading documents from the underlying MongoDB database.

Schemas can be created with NestJS decorators, or with Mongoose itself manually. Using decorators to create schemas greatly reduces boilerplate and improves overall code readability.

```typescript
// schemas/cat.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type CatDocument = Cat & Document;

@Schema()
export class Cat {
  @Prop()
  name: string;

  @Prop()
  age: number;

  @Prop()
  breed: string;
}

export const CatSchema = SchemaFactory.createForClass(Cat);
// Note you can also generate a raw schema definition using the DefinitionsFactory class (from the nestjs/mongoose). This allows you to manually modify the schema definition generated based on the metadata you provided. This is useful for certain edge-cases where it may be hard to represent everything with decorators.
```

The `@Prop()` decorator defines a property in the document.

```typescript
@Prop([String])
tags: string[];

@Prop({ required: true })
name: string;
```

In case you want to specify relation to another model, later for populating, you can use `@Prop()` decorator as well. 

```typescript
import * as mongoose from 'mongoose';
import { Owner } from '../owners/schemas/owner.schema';

// inside the class definition
@Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' })
owner: Owner;
// multiple owners
@Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' }] })
owner: Owner[];
```

**raw** schema definition can also be passed to the decorator. This is useful when, for example, a property represents a nested object which is not defined as a class. For this, use the `raw()` function from the `@nestjs/mongoose` package

```typescript
@Prop(raw({
  firstName: { type: String },
  lastName: { type: String }
}))
details: Record<string, any>;
```

Or you can define a schema manually

```typescript
export const CatSchema = new mongoose.Schema({
  name: String,
  age: Number,
  breed: String,
});
```

```typescript
// cats.module.ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { Cat, CatSchema } from './schemas/cat.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }])],
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
// If you also want to use the models in another module, add MongooseModule to the exports section of CatsModule and import CatsModule in the other module.
// Once you've registered the schema, you can inject a Cat model into the CatsService using the @InjectModel() decorator

// cats.service.ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Cat, CatDocument } from './schemas/cat.schema';
import { CreateCatDto } from './dto/create-cat.dto';

@Injectable()
export class CatsService {
  constructor(@InjectModel(Cat.name) private catModel: Model<CatDocument>) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const createdCat = new this.catModel(createCatDto);
    return createdCat.save();
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }
}
```

### Connection

[Mongoose Connection object](https://mongoosejs.com/docs/api.html#Connection)

```typescript
import { Injectable } from '@nestjs/common';
import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';

@Injectable()
export class CatsService {
  constructor(@InjectConnection() private connection: Connection) {}
}
```

### Multiple databases

[#](https://docs.nestjs.com/techniques/mongodb#multiple-databases)

### Hooks (middleware)

[#](https://docs.nestjs.com/techniques/mongodb#hooks-middleware)

### Plugin

[#](https://docs.nestjs.com/techniques/mongodb#plugins)

### Discriminators

[#](https://docs.nestjs.com/techniques/mongodb#discriminators)

### Testing

```typescript
@Module({
  providers: [
    CatsService,
    {
      provide: getModelToken(Cat.name),
      useValue: catModel, // a hardcoded catModel (object instance) will be provided whenever any consumer injects a Model<Cat> using an @InjectModel() decorator.
    },
  ],
})
export class CatsModule {}
```

### Async configuration

[#](https://docs.nestjs.com/techniques/mongodb#async-configuration)

# Configuration

[Configuration | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/configuration)

# Validation

[Validation | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/validation)

# Serialization

[Serialization | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/serialization)

# File upload

[File upload | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/file-upload)

# Sample

[nest/sample at master Â· nestjs/nest (github.com)](https://github.com/nestjs/nest/tree/master/sample)

# Others tech

[Health checks (Terminus) Nest recipes](https://docs.nestjs.com/recipes/terminus)

[Hot reload Nest recipes](https://docs.nestjs.com/recipes/hot-reload)

[Events | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/events)

[Caching | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/caching)

[Task Scheduling | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/task-scheduling)

[Queues | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/queues)

[Cookies | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/cookies)

[Session | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/session)

[MVC | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/mvc)

[Server-Sent Events | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/server-sent-events)

[Performance (Fastify) | NestJS - A progressive Node.js framework](https://docs.nestjs.com/techniques/performance)

[HTTPS & Multiple Servers - FAQ | NestJS - A progressive Node.js framework](https://docs.nestjs.com/faq/multiple-servers#https)



## Global prefix

To set a prefix for **every route** registered in an HTTP application, use the `setGlobalPrefix()` method of the `INestApplication` instance.

```typescript
const app = await NestFactory.create(AppModule);
app.setGlobalPrefix('v1');
```

## Hybrid application

A hybrid application is one that both listens for HTTP requests, as well as makes use of connected microservices. The `INestApplication` instance can be connected with `INestMicroservice` instances through the `connectMicroservice()` method.

```typescript
const app = await NestFactory.create(AppModule);
const microservice = app.connectMicroservice({
  transport: Transport.TCP,
});

await app.startAllMicroservicesAsync();
await app.listen(3001);


// To connect multiple microservice instances, issue the call to connectMicroservice() for each microservice:
const app = await NestFactory.create(AppModule);
// microservice #1
const microserviceTcp = app.connectMicroservice<MicroserviceOptions>({
  transport: Transport.TCP,
  options: {
    port: 3001,
  },
});
// microservice #2
const microserviceRedis = app.connectMicroservice<MicroserviceOptions>({
  transport: Transport.REDIS,
  options: {
    url: 'redis://localhost:6379',
  },
});

await app.startAllMicroservicesAsync();
await app.listen(3001);

// To bind @MessagePattern() to only one transport strategy (for example, MQTT) in a hybrid application with multiple microservices, we can pass the second argument of type Transport which is an enum with all the built-in transport strategies defined.
@MessagePattern('time.us.*', Transport.NATS)
getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
  console.log(`Subject: ${context.getSubject()}`); // e.g. "time.us.east"
  return new Date().toLocaleTimeString(...);
}
@MessagePattern({ cmd: 'time.us' }, Transport.TCP)
getTCPDate(@Payload() data: number[]) {
  return new Date().toLocaleTimeString(...);
}
```

### Sharing configuration

By default a hybrid application will not inherit global pipes, interceptors, guards and filters configured for the main (HTTP-based) application. To inherit these configuration properties from the main application, set the `inheritAppConfig` property in the second argument (an optional options object) of the `connectMicroservice()` call, as follow:

```typescript
const microservice = app.connectMicroservice({
  transport: Transport.TCP
}, { inheritAppConfig: true });
```
